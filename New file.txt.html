pragma solidity ^0.4.11;<div></div><br/>contract ERC20Basic {<br/>  uint256 public totalSupply;<br/>  function balanceOf(address who) public constant returns (uint256);<br/>  function transfer(address to, uint256 value) public returns (bool);<br/>  event Transfer(address indexed from, address indexed to, uint256 value);<br/>}<div></div>library SafeMath {<br/>  function mul(uint256 a, uint256 b) internal constant returns (uint256) {<br/>    uint256 c = a * b;<br/>    assert(a == 0 || c / a == b);<br/>    return c;<br/>  }<div></div>  function div(uint256 a, uint256 b) internal constant returns (uint256) {<br/>      uint256 c = a / b;<br/>      return c;<br/>  }<div></div>  function sub(uint256 a, uint256 b) internal constant returns (uint256) {<br/>    assert(b <= a);<br/>    return a - b;<br/>  }<div></div>  function add(uint256 a, uint256 b) internal constant returns (uint256) {<br/>    uint256 c = a + b;<br/>    assert(c >= a);<br/>    return c;<br/>  }<br/>}<br/>contract ERC20 is ERC20Basic {<br/>  function allowance(address owner, address spender) public constant returns (uint256);<br/>  function transferFrom(address from, address to, uint256 value) public returns (bool);<br/>  function approve(address spender, uint256 value) public returns (bool);<br/>  event Approval(address indexed owner, address indexed spender, uint256 value);<br/>}<br/>contract BasicToken is ERC20Basic {<br/>  using SafeMath for uint256;<div></div>  mapping(address => uint256) balances;<div></div>  function transfer(address _to, uint256 _value) public returns (bool) {<br/>    require(_to != address(0));<br/>    balances[msg.sender] = balances[msg.sender].sub(_value);<br/>    balances[_to] = balances[_to].add(_value);<br/>    Transfer(msg.sender, _to, _value);<br/>    return true;<br/>  }<div></div><br/>  function balanceOf(address _owner) public constant returns (uint256 balance) {<br/>    return balances[_owner];<br/>  }<div></div>}<div></div>contract StandardToken is ERC20, BasicToken {<div></div>  mapping (address => mapping (address => uint256)) allowed;<div></div><br/>  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {<br/>    require(_to != address(0));<div></div>    uint256 _allowance = allowed[_from][msg.sender];<div></div>    balances[_from] = balances[_from].sub(_value);<br/>    balances[_to] = balances[_to].add(_value);<br/>    allowed[_from][msg.sender] = _allowance.sub(_value);<br/>    Transfer(_from, _to, _value);<br/>    return true;<br/>  }<div></div><br/>  function approve(address _spender, uint256 _value) public returns (bool) {<br/>    allowed[msg.sender][_spender] = _value;<br/>    Approval(msg.sender, _spender, _value);<br/>    return true;<br/>  }<div></div><br/>  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {<br/>    return allowed[_owner][_spender];<br/>  }<div></div><br/>  function increaseApproval (address _spender, uint _addedValue)<br/>    returns (bool success) {<br/>    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);<br/>    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);<br/>    return true;<br/>  }<div></div>  function decreaseApproval (address _spender, uint _subtractedValue)<br/>    returns (bool success) {<br/>    uint oldValue = allowed[msg.sender][_spender];<br/>    if (_subtractedValue > oldValue) {<br/>      allowed[msg.sender][_spender] = 0;<br/>    } else {<br/>      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);<br/>    }<br/>    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);<br/>    return true;<br/>  }<div></div>}<div></div>contract BarterCoin is StandardToken {<br/>	string public name = "PAWS COIN"; <br/>	string public symbol = "PAW";<br/>	uint public decimals = 2;<br/>	uint public INITIAL_SUPPLY = 100000000000;<div></div>	function BarterCoin() {<br/>		totalSupply = INITIAL_SUPPLY;<br/>		balances[msg.sender] = INITIAL_SUPPLY;<br/>	}<br/>}